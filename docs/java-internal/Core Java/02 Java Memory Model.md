# JVM Memory Structure

![Memory Management in Java](.\asset\memory-management-in-java.png)

**1. Class(Method) Area**: Class(Method) Area stores per-class structures such as the runtime constant pool, field and method data, the code for methods, static variable and methods. 

- **Before Java 8**, it was part of heap memory (**PermGen**). it was require to change PermGen through -XX:PermSize or -XX:MaxPermSize, if **java.lang.OutOfMemoryError: PermGen** exception occur.
- **From Java 8, PermGen has been removed. Metaspace has been added**, which is not part of heap memory, but part of  Main Memory. And, we don't have to define Metaspace, it **can increase automatically as required.** **static variable and method get stored** in this area
- ![img](https://miro.medium.com/max/875/0*28wQjfFfyVZURF1D)

- This includes **Code Cache**
- Stores compiled code (i.e. native code) generated by JIT compiler, JVM internal structures, loaded profiler agent code and data, etc.
- When Code Cache exceeds a threshold, it gets flushed (and objects are not relocated by the GC).

**3 Heap**: It is the runtime data area in which objects are allocated.

- Heap is divided into 2 parts — Young Generation and Old Generation

- Heap is allocated when JVM starts up (Initial size: -Xms)

- Heap size increases/decreases while the application is running

- Maximum size: -Xmx

  ![img](.\asset\heap.png)

  ##  Young Generation

  - This is reserved for containing newly-allocated objects
  - Young Gen includes three parts — **Eden Memory** and two **Survivor Memory spaces (S0, S1)**
  - Most of the newly-created objects goes Eden space.
  - When Eden space is filled with objects, **Minor GC** (a.k.a. **Young Collection**) is performed and all the survivor objects are moved to one of the survivor spaces.
  - Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.
  - Objects that are survived after many cycles of GC, are moved to the Old generation memory space. Usually it’s done by setting a threshold for the age of the young generation objects before they become eligible to promote to Old generation.

  ## Old Generation

  - This is reserved for containing long lived objects that could survive after many rounds of Minor GC
  - When Old Gen space is full, **Major GC** (a.k.a. **Old Collection**) is performed (usually takes longer time)

**3. Stack**: Java Stack stores frames. It holds local variables and partial results, and plays a part in method invocation and return. Each thread has a private JVM stack, created at the same time as thread.
**4. Program Counter Register**: PC (program counter) register. It contains the address of the Java virtual machine instruction currently being executed by each thread.
**5 Native Method Stack**: It contains all the native methods used in the application.